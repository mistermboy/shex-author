{"ast":null,"code":"import Codemirror from 'codemirror';\nimport Editor from '../entities/editor';\nimport Shape from '../entities/shexEntities/shape';\nlet shapesCount = 0;\n\nfunction addShape(shapes) {\n  const id = shapes.length + shapesCount++;\n  const newShape = new Shape(id);\n  let newShapes = [];\n  newShapes = Object.assign(newShapes, shapes);\n  newShapes.push(newShape);\n  setTimeout(() => {\n    emit(newShapes);\n    return newShape;\n  }, 10);\n}\n\nfunction deleteShape(shapes, shapeId, confirm) {\n  if (!confirm) {\n    confirm = window.confirm('Are you sure?');\n  }\n\n  if (confirm == true) {\n    const newShapes = shapes.filter(shape => shape.id != shapeId);\n    emit(newShapes);\n    return newShapes;\n  }\n\n  return shapes;\n}\n\nfunction getShapeById(shapes, shapeId) {\n  return shapes.filter(function (obj) {\n    return obj.id == shapeId;\n  })[0];\n}\n\nfunction getShapeByName(shapes, name) {\n  for (let s in shapes) {\n    if (shapes[s].getType().getValue() == name) {\n      return shapes[s];\n    }\n  }\n}\n\nfunction getTripleById(shape, tripleId) {\n  return shape.getTriples().filter(function (obj) {\n    return obj.id == tripleId;\n  })[0];\n}\n\nfunction emit(newShapes) {\n  const yashe = Editor.getInstance().getYashe();\n\n  if (yashe != undefined) {\n    Codemirror.signal(yashe, 'humanEvent', newShapes);\n  }\n}\n\nconst shexUtils = {\n  addShape: addShape,\n  deleteShape: deleteShape,\n  getShapeById: getShapeById,\n  getShapeByName: getShapeByName,\n  getTripleById: getTripleById,\n  emit: emit\n};\nexport default shexUtils;","map":{"version":3,"sources":["/home/mistermboy/repositories/shex-author/src/utils/shexUtils.js"],"names":["Codemirror","Editor","Shape","shapesCount","addShape","shapes","id","length","newShape","newShapes","Object","assign","push","setTimeout","emit","deleteShape","shapeId","confirm","window","filter","shape","getShapeById","obj","getShapeByName","name","s","getType","getValue","getTripleById","tripleId","getTriples","yashe","getInstance","getYashe","undefined","signal","shexUtils"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,YAAvB;AACA,OAAOC,MAAP,MAAmB,oBAAnB;AACA,OAAOC,KAAP,MAAkB,gCAAlB;AAEA,IAAIC,WAAW,GAAG,CAAlB;;AAEA,SAASC,QAAT,CAAmBC,MAAnB,EAA0B;AAEtB,QAAMC,EAAE,GAAGD,MAAM,CAACE,MAAP,GAAgBJ,WAAW,EAAtC;AACA,QAAMK,QAAQ,GAAG,IAAIN,KAAJ,CAAUI,EAAV,CAAjB;AAEA,MAAIG,SAAS,GAAG,EAAhB;AACAA,EAAAA,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAcF,SAAd,EAAyBJ,MAAzB,CAAZ;AACAI,EAAAA,SAAS,CAACG,IAAV,CAAeJ,QAAf;AACAK,EAAAA,UAAU,CAAC,MAAM;AACbC,IAAAA,IAAI,CAACL,SAAD,CAAJ;AACA,WAAOD,QAAP;AACH,GAHS,EAGP,EAHO,CAAV;AAKH;;AAED,SAASO,WAAT,CAAqBV,MAArB,EAA4BW,OAA5B,EAAoCC,OAApC,EAA6C;AACzC,MAAG,CAACA,OAAJ,EAAY;AACRA,IAAAA,OAAO,GAAGC,MAAM,CAACD,OAAP,CAAe,eAAf,CAAV;AACH;;AACD,MAAIA,OAAO,IAAI,IAAf,EAAqB;AACjB,UAAMR,SAAS,GAAGJ,MAAM,CAACc,MAAP,CAAcC,KAAK,IAAIA,KAAK,CAACd,EAAN,IAAYU,OAAnC,CAAlB;AACAF,IAAAA,IAAI,CAACL,SAAD,CAAJ;AACA,WAAOA,SAAP;AACH;;AACD,SAAOJ,MAAP;AACH;;AAED,SAASgB,YAAT,CAAsBhB,MAAtB,EAA6BW,OAA7B,EAAsC;AAClC,SAAOX,MAAM,CAACc,MAAP,CAAc,UAAUG,GAAV,EAAgB;AACjC,WAAOA,GAAG,CAAChB,EAAJ,IAAUU,OAAjB;AACH,GAFM,EAEJ,CAFI,CAAP;AAGH;;AAED,SAASO,cAAT,CAAwBlB,MAAxB,EAA+BmB,IAA/B,EAAqC;AACjC,OAAI,IAAIC,CAAR,IAAapB,MAAb,EAAoB;AAChB,QAAGA,MAAM,CAACoB,CAAD,CAAN,CAAUC,OAAV,GAAoBC,QAApB,MAAkCH,IAArC,EAA0C;AACtC,aAAOnB,MAAM,CAACoB,CAAD,CAAb;AACH;AACJ;AACJ;;AAGD,SAASG,aAAT,CAAuBR,KAAvB,EAA6BS,QAA7B,EAAuC;AACnC,SAAOT,KAAK,CAACU,UAAN,GAAmBX,MAAnB,CAA0B,UAAUG,GAAV,EAAgB;AAC7C,WAAOA,GAAG,CAAChB,EAAJ,IAAUuB,QAAjB;AACH,GAFM,EAEJ,CAFI,CAAP;AAGH;;AAGD,SAASf,IAAT,CAAcL,SAAd,EAAyB;AACrB,QAAMsB,KAAK,GAAG9B,MAAM,CAAC+B,WAAP,GAAqBC,QAArB,EAAd;;AACA,MAAGF,KAAK,IAAEG,SAAV,EAAoB;AAChBlC,IAAAA,UAAU,CAACmC,MAAX,CAAkBJ,KAAlB,EAAwB,YAAxB,EAAqCtB,SAArC;AACH;AACJ;;AAGD,MAAM2B,SAAS,GAAG;AACdhC,EAAAA,QAAQ,EAACA,QADK;AAEdW,EAAAA,WAAW,EAACA,WAFE;AAGdM,EAAAA,YAAY,EAACA,YAHC;AAIdE,EAAAA,cAAc,EAACA,cAJD;AAKdK,EAAAA,aAAa,EAACA,aALA;AAMdd,EAAAA,IAAI,EAACA;AANS,CAAlB;AASA,eAAesB,SAAf","sourcesContent":["import Codemirror from 'codemirror';\nimport Editor from '../entities/editor';\nimport Shape from '../entities/shexEntities/shape';\n\nlet shapesCount = 0;\n\nfunction addShape (shapes){\n\n    const id = shapes.length + shapesCount++;\n    const newShape = new Shape(id);\n    \n    let newShapes = [];\n    newShapes = Object.assign(newShapes, shapes);\n    newShapes.push(newShape)\n    setTimeout(() => {\n        emit(newShapes);\n        return newShape;    \n    }, 10);\n    \n}\n\nfunction deleteShape(shapes,shapeId,confirm) {\n    if(!confirm){\n        confirm = window.confirm('Are you sure?');\n    }\n    if (confirm == true) {\n        const newShapes = shapes.filter(shape => shape.id != shapeId);\n        emit(newShapes);\n        return newShapes;\n    }\n    return shapes;\n}\n\nfunction getShapeById(shapes,shapeId) {\n    return shapes.filter(function( obj ) {\n        return obj.id == shapeId\n    })[0];\n}\n\nfunction getShapeByName(shapes,name) {\n    for(let s in shapes){\n        if(shapes[s].getType().getValue() == name){\n            return shapes[s];\n        }\n    }\n}\n\n\nfunction getTripleById(shape,tripleId) {\n    return shape.getTriples().filter(function( obj ) {\n        return obj.id == tripleId\n    })[0];\n}\n\n\nfunction emit(newShapes) {\n    const yashe = Editor.getInstance().getYashe();\n    if(yashe!=undefined){\n        Codemirror.signal(yashe,'humanEvent',newShapes);\n    }\n}\n\n\nconst shexUtils = {\n    addShape:addShape,\n    deleteShape:deleteShape,\n    getShapeById:getShapeById,\n    getShapeByName:getShapeByName,\n    getTripleById:getTripleById,\n    emit:emit\n}\n\nexport default shexUtils;"]},"metadata":{},"sourceType":"module"}