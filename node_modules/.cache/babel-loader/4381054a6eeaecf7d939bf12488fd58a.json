{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function SearchCursor(doc, query, pos, caseFold) {\n    this.atOccurrence = false;\n    this.doc = doc;\n    if (caseFold == null && typeof query == \"string\") caseFold = false;\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n    this.pos = {\n      from: pos,\n      to: pos\n    }; // The matches method is filled in based on the type of query.\n    // It takes a position and a direction, and returns an object\n    // describing the next occurrence of the query, or null if no\n    // more matches were found.\n\n    if (typeof query != \"string\") {\n      // Regexp match\n      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n\n      this.matches = function (reverse, pos) {\n        if (reverse) {\n          query.lastIndex = 0;\n          var line = doc.getLine(pos.line).slice(0, pos.ch),\n              cutOff = 0,\n              match,\n              start;\n\n          for (;;) {\n            query.lastIndex = cutOff;\n            var newMatch = query.exec(line);\n            if (!newMatch) break;\n            match = newMatch;\n            start = match.index;\n            cutOff = match.index + (match[0].length || 1);\n            if (cutOff == line.length) break;\n          }\n\n          var matchLen = match && match[0].length || 0;\n\n          if (!matchLen) {\n            if (start == 0 && line.length == 0) {\n              match = undefined;\n            } else if (start != doc.getLine(pos.line).length) {\n              matchLen++;\n            }\n          }\n        } else {\n          query.lastIndex = pos.ch;\n          var line = doc.getLine(pos.line),\n              match = query.exec(line);\n          var matchLen = match && match[0].length || 0;\n          var start = match && match.index;\n          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n        }\n\n        if (match && matchLen) return {\n          from: Pos(pos.line, start),\n          to: Pos(pos.line, start + matchLen),\n          match: match\n        };\n      };\n    } else {\n      // String query\n      var origQuery = query;\n      if (caseFold) query = query.toLowerCase();\n      var fold = caseFold ? function (str) {\n        return str.toLowerCase();\n      } : function (str) {\n        return str;\n      };\n      var target = query.split(\"\\n\"); // Different methods for single-line and multi-line queries\n\n      if (target.length == 1) {\n        if (!query.length) {\n          // Empty string would match anything and never progress, so\n          // we define it to match nothing instead.\n          this.matches = function () {};\n        } else {\n          this.matches = function (reverse, pos) {\n            if (reverse) {\n              var orig = doc.getLine(pos.line).slice(0, pos.ch),\n                  line = fold(orig);\n              var match = line.lastIndexOf(query);\n\n              if (match > -1) {\n                match = adjustPos(orig, line, match);\n                return {\n                  from: Pos(pos.line, match),\n                  to: Pos(pos.line, match + origQuery.length)\n                };\n              }\n            } else {\n              var orig = doc.getLine(pos.line).slice(pos.ch),\n                  line = fold(orig);\n              var match = line.indexOf(query);\n\n              if (match > -1) {\n                match = adjustPos(orig, line, match) + pos.ch;\n                return {\n                  from: Pos(pos.line, match),\n                  to: Pos(pos.line, match + origQuery.length)\n                };\n              }\n            }\n          };\n        }\n      } else {\n        var origTarget = origQuery.split(\"\\n\");\n\n        this.matches = function (reverse, pos) {\n          var last = target.length - 1;\n\n          if (reverse) {\n            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n            var to = Pos(pos.line, origTarget[last].length);\n\n            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln) {\n              if (target[i] != fold(doc.getLine(ln))) return;\n            }\n\n            var line = doc.getLine(ln),\n                cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            return {\n              from: Pos(ln, cut),\n              to: to\n            };\n          } else {\n            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n            var line = doc.getLine(pos.line),\n                cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            var from = Pos(pos.line, cut);\n\n            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln) {\n              if (target[i] != fold(doc.getLine(ln))) return;\n            }\n\n            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n            return {\n              from: from,\n              to: Pos(ln, origTarget[last].length)\n            };\n          }\n        };\n      }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function findNext() {\n      return this.find(false);\n    },\n    findPrevious: function findPrevious() {\n      return this.find(true);\n    },\n    find: function find(reverse) {\n      var self = this,\n          pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n\n      function savePosAndFail(line) {\n        var pos = Pos(line, 0);\n        self.pos = {\n          from: pos,\n          to: pos\n        };\n        self.atOccurrence = false;\n        return false;\n      }\n\n      for (;;) {\n        if (this.pos = this.matches(reverse, pos)) {\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        }\n\n        if (reverse) {\n          if (!pos.line) return savePosAndFail(0);\n          pos = Pos(pos.line - 1, this.doc.getLine(pos.line - 1).length);\n        } else {\n          var maxLine = this.doc.lineCount();\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n          pos = Pos(pos.line + 1, 0);\n        }\n      }\n    },\n    from: function from() {\n      if (this.atOccurrence) return this.pos.from;\n    },\n    to: function to() {\n      if (this.atOccurrence) return this.pos.to;\n    },\n    replace: function replace(newText, origin) {\n      if (!this.atOccurrence) return;\n      var lines = CodeMirror.splitLines(newText);\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n    }\n  }; // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n\n  function adjustPos(orig, folded, pos) {\n    if (orig.length == folded.length) return pos;\n\n    for (var pos1 = Math.min(pos, orig.length);;) {\n      var len1 = orig.slice(0, pos1).toLowerCase().length;\n      if (len1 < pos) ++pos1;else if (len1 > pos) --pos1;else return pos1;\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function (query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold);\n  });\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function (query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n  CodeMirror.defineExtension(\"selectMatches\", function (query, caseFold) {\n    var ranges = [];\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n      ranges.push({\n        anchor: cur.from(),\n        head: cur.to()\n      });\n    }\n\n    if (ranges.length) this.setSelections(ranges, 0);\n  });\n});","map":null,"metadata":{},"sourceType":"script"}