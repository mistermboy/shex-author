{"ast":null,"code":"import shexUtils from './shexUtils';\nimport Editor from '../entities/editor';\nimport Shape from '../entities/shexEntities/shape';\nimport Triple from '../entities/shexEntities/triple';\nimport TypesFactory from '../entities/shexEntities/types/typesFactory';\nimport PrefixedIri from '../entities/shexEntities/types/concreteTypes/prefixedIri';\nimport IriRef from '../entities/shexEntities/types/concreteTypes/iriRef';\nimport BNode from '../entities/shexEntities/types/concreteTypes/bNode';\nimport Primitive from '../entities/shexEntities/types/concreteTypes/primitive';\nimport ShapeReference from '../entities/shexEntities/types/concreteTypes/shapeReference';\nimport Literal from '../entities/shexEntities/types/concreteTypes/kinds/literal';\nimport NonLiteral from '../entities/shexEntities/types/concreteTypes/kinds/nonLiteral';\nimport IriKind from '../entities/shexEntities/types/concreteTypes/kinds/iriKind';\nimport BNodeKind from '../entities/shexEntities/types/concreteTypes/kinds/bNodeKind';\nimport BlankKind from '../entities/shexEntities/types/concreteTypes/kinds/blankKind';\nimport Prefix from '../entities/shexEntities/shexUtils/prefix';\nimport InlineShape from '../entities/shexEntities/shexUtils/inlineShape'; //HAY QUE METER TODOS\n\nconst PRIMITIVES = ['string', 'integer', 'date', 'boolean'];\nconst CARDINALITY = ['*', '?', '+'];\nlet inlines;\n\nfunction getTokens() {\n  let yashe = Editor.getInstance().getYashe();\n  let tokens = [];\n\n  if (yashe != undefined) {\n    let numPrefixes = Object.keys(yashe.getDefinedPrefixes()).length;\n\n    for (var l = numPrefixes + 1; l < yashe.lineCount(); ++l) {\n      let lineTokens = getNonWsTokens(yashe.getLineTokens(l));\n      lineTokens.forEach(token => {\n        tokens.push(token);\n      });\n    }\n  }\n\n  return tokens;\n}\n\nfunction getDefinedShapes(tokens) {\n  let brackets = 0;\n  let shape = [];\n  let defShapes = []; //Separate shapes in arrays\n\n  tokens.forEach(element => {\n    shape.push(element);\n\n    if (element.string == '{') {\n      brackets++;\n    }\n\n    if (element.string == '}') {\n      brackets--; //Is the last } ?\n\n      if (brackets == 0) {\n        defShapes.push(shape);\n        shape = [];\n      }\n    }\n  });\n  return defShapes;\n}\n\nfunction getShapes(defShapes) {\n  inlines = [];\n  let shapes = [];\n  let yashe = Editor.getInstance().getYashe();\n  defShapes.forEach(shape => {\n    let id = shapes.length;\n    let shapeDef = shape[0].string;\n    let shapeType = getType(shapeDef, 'shapeName');\n    let qualifier = getQualifier(shape);\n    let triples = getTriples(id, shape);\n    shapes.push(new Shape(id, shapeType, triples, qualifier));\n  });\n  return shapes;\n}\n\nfunction getQualifier(shape) {\n  if (shape[1].type == 'keyword') {\n    let type = shape[1].string.toLowerCase();\n    return new TypesFactory().createType(type);\n  }\n\n  return new BlankKind();\n}\n\nfunction getTriples(shapeId, shape) {\n  let triples = [];\n  let singleTriple = [];\n  let yashe = Editor.getInstance().getYashe();\n  let start = getStart(shape);\n\n  for (let i = start; i < shape.length; i++) {\n    singleTriple.push(shape[i]);\n\n    if (shape[i].type == 'punc') {\n      // finish of the triple ';'\n      if (singleTriple.length != 1) {\n        //This line is neccesary when last triple of the shape ends with ';'\n        triples.push(getTriple(triples, singleTriple, shapeId));\n        singleTriple = [];\n      }\n    }\n  }\n\n  return triples;\n}\n\nfunction getTriple(triples, singleTriple, shapeId) {\n  let id = triples.length;\n  let type;\n  let value;\n  let cardinality;\n  let inlineShape = new InlineShape();\n  let inlineName;\n  let index = 0;\n\n  for (let s in singleTriple) {\n    let token = singleTriple[s];\n\n    if (index == 0) {\n      type = getType(token.string, 'tripleName');\n    } else {\n      if (token.type == 'string-2' || token.type == 'keyword' || token.type == 'variable-3') {\n        value = getValue(token.string);\n      }\n\n      if (token.type == 'at') {\n        inlineName = getInlineName(token.string);\n        inlines.push({\n          shapeId: shapeId,\n          tripleId: id,\n          inlineName: inlineName\n        });\n      }\n\n      if (token.type == 'card') {\n        cardinality = token.string;\n      }\n    }\n\n    index++;\n  } //ShapeRef\n\n\n  if (inlineName != undefined) {\n    let ref;\n\n    if (value != undefined) {\n      ref = value.getTypeName();\n    }\n\n    value = new ShapeReference(ref);\n  }\n\n  return new Triple(id, type, value, inlineShape, cardinality);\n}\n\nfunction getStart(shape) {\n  for (let i = 0; i < shape.length; i++) {\n    if (shape[i].string == '{') {\n      return i + 1;\n    }\n  }\n}\n\nfunction getValue(def) {\n  let factory = new TypesFactory();\n  let type = factory.createType(def.toLowerCase());\n\n  if (type != undefined) {\n    return type;\n  }\n\n  if (def.startsWith('<')) {\n    let value = def.split('<')[1].split('>')[0];\n    return new IriRef('valueName', value);\n  }\n\n  let token = def.split(':');\n  let yashe = Editor.getInstance().getYashe();\n\n  if (token.length == 2) {\n    //At this point it can be Prefixed,Primitive or ShapeRef\n    if (isPrimitive(token[1])) {\n      return new Primitive(token[1]);\n    } else {\n      let prefixName = token[0];\n      let prefixValue = getPrefixValue(yashe.getDefinedPrefixes(), prefixName);\n      let prefix = new Prefix(prefixName, prefixValue);\n      return new PrefixedIri('valueName', prefix, token[1]);\n    }\n  }\n}\n\nfunction getType(def, context) {\n  let value;\n  let yashe = Editor.getInstance().getYashe();\n\n  if (def.startsWith('<')) {\n    value = def.split('<')[1].split('>')[0];\n    return new IriRef(context, value);\n  } else if (def.startsWith('_:')) {\n    value = def.split(':')[1];\n    return new BNode(context, value);\n  } else {\n    value = def.split(':')[1];\n    let prefixName = def.split(':')[0];\n    let prefixValue = getPrefixValue(yashe.getDefinedPrefixes(), prefixName);\n    let prefix = new Prefix(prefixName, prefixValue);\n    return new PrefixedIri(context, prefix, value);\n  }\n}\n\nfunction updateInlines(shapes) {\n  for (let inShape in inlines) {\n    let shapeId = inlines[inShape].shapeId;\n    let tripleId = inlines[inShape].tripleId;\n    let name = inlines[inShape].inlineName;\n    let shape = shexUtils.getShapeById(shapes, shapeId);\n    let triple = shexUtils.getTripleById(shape, tripleId);\n    let shapeRef = shexUtils.getShapeByName(shapes, name);\n    triple.getInlineShape().setShape(shapeRef);\n  }\n}\n\nfunction getPrefixValue(defPrefixes, prefixName) {\n  let prefixValue;\n\n  for (let pre in defPrefixes) {\n    if (pre == prefixName) {\n      prefixValue = defPrefixes[pre];\n    }\n  }\n\n  return prefixValue;\n}\n\nfunction isPrimitive(value) {\n  for (let prim in PRIMITIVES) {\n    if (PRIMITIVES[prim] == value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getInlineName(token) {\n  if (token.startsWith('@<')) {\n    return token.split('<')[1].split('>')[0];\n  }\n\n  return token.split(':')[1];\n}\n\nfunction getNonWsTokens(tokens) {\n  return tokens.filter(function (obj) {\n    return obj.type != 'ws';\n  });\n}\n\nconst tokenUtils = {\n  getTokens: getTokens,\n  getDefinedShapes: getDefinedShapes,\n  getShapes: getShapes,\n  updateInlines: updateInlines\n};\nexport default tokenUtils;","map":{"version":3,"sources":["/home/mistermboy/repositories/shex-author/src/utils/tokenUtils.js"],"names":["shexUtils","Editor","Shape","Triple","TypesFactory","PrefixedIri","IriRef","BNode","Primitive","ShapeReference","Literal","NonLiteral","IriKind","BNodeKind","BlankKind","Prefix","InlineShape","PRIMITIVES","CARDINALITY","inlines","getTokens","yashe","getInstance","getYashe","tokens","undefined","numPrefixes","Object","keys","getDefinedPrefixes","length","l","lineCount","lineTokens","getNonWsTokens","getLineTokens","forEach","token","push","getDefinedShapes","brackets","shape","defShapes","element","string","getShapes","shapes","id","shapeDef","shapeType","getType","qualifier","getQualifier","triples","getTriples","type","toLowerCase","createType","shapeId","singleTriple","start","getStart","i","getTriple","value","cardinality","inlineShape","inlineName","index","s","getValue","getInlineName","tripleId","ref","getTypeName","def","factory","startsWith","split","isPrimitive","prefixName","prefixValue","getPrefixValue","prefix","context","updateInlines","inShape","name","getShapeById","triple","getTripleById","shapeRef","getShapeByName","getInlineShape","setShape","defPrefixes","pre","prim","filter","obj","tokenUtils"],"mappings":"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","sourcesContent":["import shexUtils from './shexUtils';\n\nimport Editor from '../entities/editor';\n\nimport  Shape from '../entities/shexEntities/shape';\nimport  Triple from '../entities/shexEntities/triple';\n\nimport TypesFactory from '../entities/shexEntities/types/typesFactory';\n\nimport PrefixedIri from '../entities/shexEntities/types/concreteTypes/prefixedIri';\nimport IriRef from '../entities/shexEntities/types/concreteTypes/iriRef';\nimport BNode from '../entities/shexEntities/types/concreteTypes/bNode';\nimport Primitive from '../entities/shexEntities/types/concreteTypes/primitive';\nimport ShapeReference from '../entities/shexEntities/types/concreteTypes/shapeReference';\n\nimport Literal from '../entities/shexEntities/types/concreteTypes/kinds/literal';\nimport NonLiteral from '../entities/shexEntities/types/concreteTypes/kinds/nonLiteral';\nimport IriKind from '../entities/shexEntities/types/concreteTypes/kinds/iriKind';\nimport BNodeKind from '../entities/shexEntities/types/concreteTypes/kinds/bNodeKind';\nimport BlankKind from '../entities/shexEntities/types/concreteTypes/kinds/blankKind';\n\n\n\nimport Prefix from '../entities/shexEntities/shexUtils/prefix';\n\nimport InlineShape from '../entities/shexEntities/shexUtils/inlineShape';\n\n\n//HAY QUE METER TODOS\nconst PRIMITIVES = ['string','integer','date','boolean'];\nconst CARDINALITY = ['*','?','+'];\n\n\nlet inlines;\n\nfunction getTokens(){\n    let yashe = Editor.getInstance().getYashe();\n    let tokens =[];\n    if(yashe!=undefined){\n        let numPrefixes = Object.keys(yashe.getDefinedPrefixes()).length;\n        for (var l = numPrefixes+1; l < yashe.lineCount(); ++l) {\n            let lineTokens = getNonWsTokens(yashe.getLineTokens(l));\n            lineTokens.forEach(token =>{\n                tokens.push(token);\n            })\n\n        }\n    }\n    return tokens;\n}\n\nfunction getDefinedShapes(tokens){\n    let brackets=0\n    let shape=[];\n    let defShapes = [];\n    //Separate shapes in arrays\n    tokens.forEach(element =>{\n        shape.push(element);\n        if(element.string == '{'){\n            brackets++;\n        }\n\n        if(element.string == '}'){\n            brackets--;\n            //Is the last } ?\n            if(brackets==0){\n                defShapes.push(shape);\n                shape = [];\n            }\n        }\n\n    })\n    return defShapes;\n}\n\n\nfunction getShapes(defShapes){\n    inlines = [];\n    let shapes = [];\n    let yashe = Editor.getInstance().getYashe();\n\n    defShapes.forEach(shape => {\n        let id = shapes.length;\n        let shapeDef = shape[0].string;\n        let shapeType = getType(shapeDef,'shapeName');\n        let qualifier = getQualifier(shape);\n        let triples = getTriples(id,shape);\n\n        shapes.push(new Shape(id,shapeType,triples,qualifier));\n    })\n    return shapes;\n\n}\n\nfunction getQualifier(shape) {\n    if(shape[1].type == 'keyword'){\n        let type = shape[1].string.toLowerCase();\n        return new TypesFactory().createType(type);\n    }\n    return new BlankKind();\n}\n\nfunction getTriples(shapeId,shape) {\n        let triples = [];\n        let singleTriple = [];\n        let yashe = Editor.getInstance().getYashe();\n        let start = getStart(shape);\n        for(let i=start;i<shape.length;i++){\n            singleTriple.push(shape[i])\n            if(shape[i].type == 'punc'){// finish of the triple ';'\n                if(singleTriple.length!=1){ //This line is neccesary when last triple of the shape ends with ';'\n           \n                    triples.push(getTriple(triples,singleTriple,shapeId));\n                    singleTriple = [];\n                }\n            }\n\n        }\n    return triples;\n}\n\nfunction getTriple(triples,singleTriple,shapeId) {\n    let id = triples.length;\n    let type;\n    let value;\n    let cardinality;\n    let inlineShape = new InlineShape();\n    let inlineName;\n    let index = 0;\n    for(let s in singleTriple){\n        let token = singleTriple[s];\n        \n        if(index == 0){\n            type = getType(token.string,'tripleName');\n            \n        }else{\n   \n            if(token.type == 'string-2' || token.type == 'keyword' || token.type == 'variable-3'){\n                value = getValue(token.string);\n            }\n    \n            if(token.type == 'at' ){\n                \n                inlineName = getInlineName(token.string);\n                inlines.push(\n                        {\n                            shapeId:shapeId,\n                            tripleId:id,\n                            inlineName:inlineName\n                        }\n                    );\n            }\n\n            if(token.type == 'card' ){\n                cardinality = token.string;\n            }\n\n        }\n        index++;\n    }\n\n\n    //ShapeRef\n    if(inlineName != undefined){\n        let ref;\n        if(value!= undefined){\n           ref = value.getTypeName();\n        }\n        value = new ShapeReference(ref); \n    }\n\n    return new Triple(id,type,value,inlineShape,cardinality);\n}\n\nfunction getStart(shape){\n    for(let i=0;i<shape.length;i++){\n        if(shape[i].string=='{'){\n            return i+1;\n        }\n    }\n}\n\n\n\nfunction getValue(def) {\n\n    let factory = new TypesFactory();\n    let type = factory.createType(def.toLowerCase());\n\n    if(type!=undefined){\n        return type;\n    }\n\n\n    if(def.startsWith('<')){\n        let value = def.split('<')[1].split('>')[0];\n        return new IriRef('valueName',value);\n    }\n\n    let token = def.split(':');\n    let yashe = Editor.getInstance().getYashe();\n\n    if(token.length==2){\n        //At this point it can be Prefixed,Primitive or ShapeRef\n        if(isPrimitive(token[1])){\n            return new Primitive(token[1]);\n        }else{\n            let prefixName = token[0];\n            let prefixValue = getPrefixValue(yashe.getDefinedPrefixes(),prefixName)\n            let prefix = new Prefix(prefixName,prefixValue);\n            return  new PrefixedIri('valueName',prefix,token[1]);\n        }\n\n    }\n \n}\n\nfunction getType(def,context) {\n    let value;\n    let yashe = Editor.getInstance().getYashe();\n    if(def.startsWith('<')){\n        value = def.split('<')[1].split('>')[0];\n        return new IriRef(context,value);\n    }else if(def.startsWith('_:')){\n        value = def.split(':')[1];\n        return new BNode(context,value);\n    }else{\n        value = def.split(':')[1];\n        let prefixName = def.split(':')[0];\n        let prefixValue = getPrefixValue(yashe.getDefinedPrefixes(),prefixName)\n        let prefix = new Prefix(prefixName,prefixValue);\n        return new PrefixedIri(context,prefix,value);\n    }\n}\n\n\nfunction updateInlines(shapes) {\n\n    for(let inShape in inlines){\n  \n        let shapeId = inlines[inShape].shapeId;\n        let tripleId = inlines[inShape].tripleId;\n        let name = inlines[inShape].inlineName;\n\n        let shape = shexUtils.getShapeById(shapes,shapeId);\n        let triple = shexUtils.getTripleById(shape,tripleId);\n\n        let shapeRef = shexUtils.getShapeByName(shapes,name);\n        triple.getInlineShape().setShape(shapeRef);\n\n    }\n}\n\n\n\nfunction getPrefixValue(defPrefixes,prefixName){\n    let prefixValue;\n    for(let pre in defPrefixes){\n        if(pre==prefixName){\n            prefixValue = defPrefixes[pre]\n        }\n    }\n    return prefixValue;\n}\n\n\nfunction isPrimitive(value) {\n    for(let prim in PRIMITIVES){\n        if(PRIMITIVES[prim] == value){\n            return true;\n        }\n    }\n    return false;\n}\n\n\nfunction getInlineName(token) {\n    if(token.startsWith('@<')){\n        return token.split('<')[1].split('>')[0];\n    }\n    return token.split(':')[1];\n}\n\n\nfunction getNonWsTokens(tokens){\n    return tokens.filter(function(obj){\n        return obj.type != 'ws';\n    })\n}\n\nconst tokenUtils = {\n    getTokens:getTokens,\n    getDefinedShapes:getDefinedShapes,\n    getShapes:getShapes,\n    updateInlines:updateInlines\n}\n\nexport default tokenUtils;"]},"metadata":{},"sourceType":"module"}